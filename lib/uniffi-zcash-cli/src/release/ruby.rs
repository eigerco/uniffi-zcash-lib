use crate::release::Config;
use std::{fs::OpenOptions, io::Write, ops::Add, process::Command};

use fs_extra::{
    dir::{self, CopyOptions},
    file,
};
use serde_json::json;

use crate::helper::{
    clean_dir, cmd_success, in_file_template_replace, tmp_folder, LINUX_SHARED_LIB_NAME,
    MACOS_SHARED_LIB_NAME,
};

pub fn run(cfg: &Config) -> anyhow::Result<()> {
    cfg.bindings_dir.try_exists()?;
    clean_dir(&cfg.package_dir)?;

    dir::copy(
        &cfg.package_template_dir,
        &cfg.package_dir,
        &CopyOptions::new().content_only(true),
    )?;

    // Copy all needed files from previously generated bindings operation
    file::copy(
        cfg.bindings_dir.join(LINUX_SHARED_LIB_NAME),
        cfg.package_dir.join("lib").join(LINUX_SHARED_LIB_NAME),
        &file::CopyOptions::default(),
    )?;
    file::copy(
        cfg.bindings_dir.join(MACOS_SHARED_LIB_NAME),
        cfg.package_dir.join("lib").join(MACOS_SHARED_LIB_NAME),
        &file::CopyOptions::default(),
    )?;
    file::copy(
        cfg.bindings_dir.join("zcash.rb"),
        cfg.package_dir.join("lib").join("zcash.rb"),
        &file::CopyOptions::default(),
    )?;

    // Modify in place the gemspec in order to set version in the template.

    let gemspec_path = cfg.package_dir.join("zcash.gemspec");
    in_file_template_replace(gemspec_path, &json!({ "version": cfg.version }))?;

    // Super hack ðŸ”¥. In order to be able to load shared library provided in the gem,
    // we need either to provide to the "ffi_lib" function loader (see zcash.rb) an absolute path
    // or a library name which was previously added to $LD_LIBRARY_PATH for lookup.
    //
    // In our case we want the former option. That is normally done by using the
    // caller file (zcash.rb) as reference, calculating the absolute path from its path.
    // But the zcash.rb file is generated by UniFFI and its out of our control.
    // So, we search and replace after the "bindgen" CLI command generates it.
    // We also make use of the 'os' gem, in order to detect in runtime what shared
    // library its needed .so or .dylib.

    let binding_file = cfg.package_dir.join("lib").join("zcash.rb");
    let original_content = file::read_to_string(&binding_file)?;
    let content = "require 'os' \n".to_string().add(&original_content);
    let result = content.replace(
        "ffi_lib 'uniffi_zcash'",
        "ffi_lib File.join(File.dirname(File.expand_path(__FILE__)), '/libuniffi_zcash' + (OS.windows? && '.dll' || OS.mac? && '.dylib' || '.so'))",
    );

    let mut file = OpenOptions::new()
        .write(true)
        .truncate(true)
        .open(binding_file)?;
    file.write_all(result.as_bytes())?;

    // Prepare Ruby distribution files

    cmd_success(
        Command::new("gem")
            .arg("build")
            .arg("zcash.gemspec")
            .current_dir(&cfg.package_dir)
            .spawn()?
            .wait(),
    )?;

    // Install and test
    cmd_success(
        Command::new("gem")
            .arg("install")
            .arg(format!("./zcash-{}.gem", cfg.version))
            .current_dir(&cfg.package_dir)
            .spawn()?
            .wait(),
    )?;

    let test_app_path = tmp_folder()?;
    dir::copy(
        &cfg.test_app_template_dir,
        &test_app_path,
        &CopyOptions::new().content_only(true),
    )?;

    cmd_success(
        Command::new("ruby")
            .arg("app.rb")
            .current_dir(test_app_path)
            .spawn()?
            .wait(),
    )
}
